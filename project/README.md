# collecterrs

Инструмент, который собирает возможные возвращаемые ошибки из сервисов в привязке к каждому отдельному методу.
Умеет собирать вложенные ошибки как из слоев самого сервиса, так и смежных сервисов определенной структуры.

Основная суть заключается в разделении ошибок на 2 класса - `именованные` и `неименованные`.
Именованные ошибки объявляются сразу с понятным описанием и кодом, и используются в явном виде. 
Благодаря этому мы можем теперь их отследить и собрать в справочник, и передавать вместе с остальным контрактом.
Именованной нужно делать ошибку, которая:
- является ошибкой бизнес-процесса, и пользователь какими-то своими действиями может повлиять на процесс так, что ошибка исчезнет / либо ему важно о ней знать в UI
для таких ошибок заведен `TypeUserRelatedError`, и его нужно обязательно обрабатывать на фронте.
- является технической ошибкой, о которой разработчики сервиса хотят явно оповестить других разработчиков-потребителей сервиса.
для таких ошибок заведен `TypeInternalError`. Отличие от неименованной ошибки здесь в том, что исправить ситуацию должны как раз потребители. 
Например - неправильная конфигурация интеграции, нужно передавать токен с определенными правами, которых сейчас нет.
Но для пользователя это общая ошибка сервиса.

В остальных случаях нет смысла оборачивать ошибку, и в обычном виде ее можно создавать/прокидывать. 
Неименованная ошибка по сути InternalError, и разработчик должен прийти и починить её. Все детали он получит из логов/трейсинга.

## Структура проекта и сервисов, основные ограничения

Пример проекта находтся в директории `project`. 
В `main.go` запускается анализатор для этого проекта, и пишет результат в `project-errors.json`.
Сервис `dummy` содержит иллюстрацию основных кейсов обработки ошибок, без логики. 
Сервисы `users` и `otp` содержат некоторую логику, связи, и могут быть запущены (нужен поднятый redis), попытка показать реальные сервисы.

1. Монорепозиторий на Golang. Каждый метод сервиса называется юзкейсом (usecase).
1. Все ошибки сервисов вынесены в отдельный пакет errs, это именованные ошибки.
1. В сервисе явно выделен слой работы с базой Storage. Он может возвращать именованную ошибку сервиса. 
(При наличии других явных слоев их тоже можно добавить в обработку, проблем быть не должно)
1. Все обращения в другие сервисы или инструменты сделаны через общий слой Providers.


## Алгоритм работы

1. Для каждого сервиса
- Собираем ошибки из Storage если есть
- Пробегаемся с помощью ast по методам и функциям, собираем встречающиеся ошибки
- Собираем все встречающиеся вызовы Providers
- Собираем все обрабатываемые ошибки, которые встречаются нам в выражениях errors.Is или ...Errors.Is (кастомный обработчик)
2. Собираем общий список - разворачиваем вызовы Providers, вставляя ошибки из вложенных сервисов в основной
- Дополнительно проверяем, что новые ошибки не указаны в обрабатываемом списке
- Повторяем до тех пор, пока встречаются вызовы провайдеров

### Логика обрабатываемых ( =исключаемых ) ошибок

У нас есть несколько сценариев.
1. Мы получили ошибку и ничего не хотим с ней делать. Возврат простым `return nil, err` доставит дальше всё, что нужно.
2. Мы получили ошибку, но не хотим отдавать по ней детали / хотим вернуть свою более общую.
```
if err != nil {
    if errsOtp.MaxCodeChecksExceededError.Is(err) {
        return nil, errors.New("Невозможно провалидировать код")
    }
    return nil, err
}
```
Это тоже простая ситуация, очевидно что здесь MaxCodeChecksExceeded уже не будет встречаться в `err` дальше.

3. Мы получили ошибку, и для конкретной именной мы хотим идти дальше, а все остальные вернуть.
```
if err != nil && !errors.Is(err, errsUsers.UserNotFoundError) {
    return nil, err
}
```
Кейс посложнее. Почему UserNotFound также будет обрабатываемой и не должен быть в списке возможных ошибок?
Потому что раз мы сразу не сделали return, то дальше будет какая-то обработка и лучше вернуть свою ошибку сервиса уже.
Если сделать логику, а потом дальше return errsUsers.UserNotFoundError - алгоритм не поймет на текущий момент.
Также алгоритм не поймет, если в одном юзкейсе будет 2 отдельных вызова одного и того же метода с разной обработкой.
Потому что список обрабатываемых ошибок собирается для юзкейса и применяется после циклической вставки вложенных ошибок, там логику сложно отследить. 
Но кажется что и кейсы достаточно редкие.

### Ошибки GRPC

Важно помнить, что при вызове через провайдера сервис по GRPC, мы получаем grpc.status, который выглядит как err.
Поэтому проверка errors.Is(err, errs.MyError) не сработает.

Здесь используется NewServiceError, который имеет свой Is(err). А внутри происходит построение ошибки из данных GRPC.
В том числе произойдет создание из неименованной ошибки - это станет понятно по пустому Desciption, а в Code будет сам текст.
Анализатор умеет отслеживать обрабатываемые таким образом ошибки.